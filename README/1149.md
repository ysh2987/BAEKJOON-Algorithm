## RGB거리 - 1149

- RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

- 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
  - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
  - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
  - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## 입력

- 첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

## 출력

- 첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

## 예제 입/출력

```
// TC1
// 입력
3
26 40 83
49 60 57
13 89 99

// 출력
96

// TC2
// 입력
3
1 100 100
100 1 100
100 100 1

// 출력
3

```

## 코드

```javascript
const fs = require("fs");
const input = fs.readFileSync("./dev/stdin").toString().trim().split("\n");
[N, ...arr] = input;
arr = arr.map((el) => el.split(" ").map(Number));

for (let i = 1; i < N; i++) {
  arr[i][0] = Math.min(arr[i - 1][1], arr[i - 1][2]) + arr[i][0];
  arr[i][1] = Math.min(arr[i - 1][0], arr[i - 1][2]) + arr[i][1];
  arr[i][2] = Math.min(arr[i - 1][0], arr[i - 1][1]) + arr[i][2];
}
console.log(Math.min(...arr[N - 1]));
```

## 풀이 방법

- 문제에 3개의 규칙이 있지만 사실 이전의 선택 인덱스와 자신의 선택 인덱스만 겹치지 않으면 된다.
- 집의 수(N)이 2 이상이기 때문에 1번 인덱스부터 자기 인덱스 번호를 제외한 이전의 인덱스 중 최소값과 본인이 선택할 값을 업데이트 하면서 원본 arr을 갱신 해주어 마지막 인덱스 값들 중 최소값을 구하면 해를 찾을 수 있다.
